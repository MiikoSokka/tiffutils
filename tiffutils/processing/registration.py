# coding: utf-8
# Author: Miiko Sokka

import os
import numpy as np
import tifffile as tiff
from skimage.registration import phase_cross_correlation

import numpy as np
from skimage.registration import phase_cross_correlation

def register_arrays(arrays, fiducial_channel):
    """
    Registers a list of image stacks using fiducial beads on the specified channel.

    Parameters:
    - arrays (list of np.ndarray): List of 4D image stacks with shape (Z, C, Y, X)
    - fiducial_channel (int): Index of the channel used for registration

    Returns:
    - registered_arrays (list of np.ndarray): List with the fixed array first, followed by registered arrays
    """
    if not arrays:
        raise ValueError("Input array list is empty.")

    fixed_image = arrays[0]
    registered_arrays = [fixed_image]

    for j, moving_image in enumerate(arrays[1:], start=1):
        try:
            print(f"\nRegistering: Timepoint {j}")

            # Compute 3D shift on fiducial channel
            shift, error, diffphase = phase_cross_correlation(
                fixed_image[:, fiducial_channel, :, :],
                moving_image[:, fiducial_channel, :, :],
                upsample_factor=1
            )
            print("ZYX Shift:", shift)

            # Apply shift to all channels
            shift_z, shift_y, shift_x = map(int, shift)
            registered_image = np.zeros_like(moving_image)
            for c in range(moving_image.shape[1]):
                registered_image[:, c, :, :] = np.roll(
                    moving_image[:, c, :, :],
                    shift=(shift_z, shift_y, shift_x),
                    axis=(0, 1, 2)
                )

            registered_arrays.append(registered_image)

        except Exception as e:
            print(f"Error registering moving image at timepoint {j}: {e}")
            registered_arrays.append(moving_image)  # Append unmodified image if registration fails

    print("Registration completed.")
    return registered_arrays

import os
import numpy as np
import tifffile as tiff
import tiffutils as tiffu
from skimage.registration import phase_cross_correlation


def register_stacks_from_paths(inputpaths, outputpaths, fiducial_channel, save_tiff_fn):
    """
    This function is intended to register files generated by Opera Phenix, in which the images for each round are 
    in a separate folder, but the filenames are same for each round.
    
    Registers a series of TIFF stacks to the first stack using a fiducial channel,
    loading only two stacks into memory at a time.

    The script does histogram stretching before computing the drift, because this is found to result in
    more accurate registration. However, the original image format is saved after registration.

    Parameters
    ----------
    inputpaths : list of str or Path
        Input TIFF file paths (4D, ZCYX). First file is the reference.
    outputpaths : list of str or Path
        Output TIFF file paths for saving. Must match inputpaths length.
    fiducial_channel : int
        Index of channel used for registration.
    save_tiff_fn : callable
        Function used to save TIFFs: save_tiff_fn(array, save_path)
    """

    if not inputpaths:
        raise ValueError("Input path list is empty.")

    if len(inputpaths) != len(outputpaths):
        raise ValueError("inputpaths and outputpaths must be the same length.")

    # Load fixed/reference image
    print(f"Loading reference stack:\n  {inputpaths[0]}")
    fixed_image = tiff.imread(str(inputpaths[0]))

    if fixed_image.ndim != 4:
        raise ValueError(f"Reference stack must be 4D (Z, C, Y, X). Got {fixed_image.shape}")

    # Save fixed image as-is
    print(f"Saving reference stack (unregistered) to:\n  {outputpaths[0]}")
    save_tiff_fn(fixed_image, str(outputpaths[0]))

    fixed_image_ = tiffu.convert_dtype(tiffu.histogram_stretch(fixed_image[:, fiducial_channel, :, :]), 'uint8')

    # Register remaining stacks
    for idx, (in_path, out_path) in enumerate(zip(inputpaths[1:], outputpaths[1:]), start=1):
        print(f"\nProcessing timepoint {idx}:")
        print(f"  Input : {in_path}")
        print(f"  Output: {out_path}")

        try:
            moving_image = tiff.imread(str(in_path))

            if moving_image.ndim != 4:
                raise ValueError(
                    f"Moving stack must be 4D (Z, C, Y, X). Got {moving_image.shape}"
                )

            # Validate fiducial channel
            if fiducial_channel >= moving_image.shape[1]:
                raise ValueError(
                    f"Fiducial channel {fiducial_channel} is out of bounds for C={moving_image.shape[1]}"
                )

            # Compute shift on fiducial channel
            shift, error, diffphase = phase_cross_correlation(
                fixed_image_,
                tiffu.convert_dtype(tiffu.histogram_stretch(moving_image[:, fiducial_channel, :, :]), 'uint8'),
                upsample_factor=1,
            )
            print("  ZYX shift:", shift)
            print("  Registration error:", error)

            # Apply shift
            shift_z, shift_y, shift_x = map(int, shift)
            registered_image = np.zeros_like(moving_image)

            for c in range(moving_image.shape[1]):
                registered_image[:, c, :, :] = np.roll(
                    moving_image[:, c, :, :],
                    shift=(shift_z, shift_y, shift_x),
                    axis=(0, 1, 2),
                )

            # Save using your save_tiff()
            save_tiff_fn(registered_image, str(out_path))
            print("  Saved registered stack.")

        except Exception as e:
            print(f"  Error registering timepoint {idx}: {e}")
            print("  Saving unregistered stack instead.")

            try:
                if "moving_image" in locals():
                    save_tiff_fn(moving_image, str(out_path))
                else:
                    fallback = tiff.imread(str(in_path))
                    save_tiff_fn(fallback, str(out_path))
            except Exception as e2:
                print(f"  Additional error while saving fallback stack: {e2}")

    print("\nRegistration (file-based) completed.")